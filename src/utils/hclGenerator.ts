import type { Edge, Node } from 'reactflow';
import type { ModuleNodeData } from '../store/editorStore';
import { getResourceName } from './resourceUtils';

const generateOutput = (node: Node<ModuleNodeData>, edges: Edge[], nodes: Node<ModuleNodeData>[]): string => {
    const name = getResourceName(node);
    const { variables } = node.data;
    
    let hcl = `output "${name}" {\n`;
    
    if (variables.description) {
        hcl += `  description = "${variables.description}"\n`;
    }
    
    // Check if value is connected via edge
    const incomingEdge = edges.find(edge => edge.target === node.id && edge.targetHandle === 'value');
    if (incomingEdge) {
        const sourceNode = nodes.find(n => n.id === incomingEdge.source);
        if (sourceNode) {
            const sourceName = getResourceName(sourceNode);
            hcl += `  value = ${sourceNode.data.type}.${sourceName}.${incomingEdge.sourceHandle || 'id'}\n`;
        }
    } else if (variables.value) {
        hcl += `  value = ${variables.value}\n`;
    }
    
    if (variables.sensitive) {
        hcl += `  sensitive = ${variables.sensitive}\n`;
    }
    
    hcl += `}\n`;
    return hcl;
};

export const generateHCL = (nodes: Node<ModuleNodeData>[], edges: Edge[]) => {
    let hcl = '# Generated by Terraform Visual Editor\n\n';

    // Separate resources and outputs
    const resources = nodes.filter(n => n.data.type !== 'output');
    const outputs = nodes.filter(n => n.data.type === 'output');

    // Generate resources first
    resources.forEach((node) => {
        const { type, variables } = node.data;
        const resourceName = getResourceName(node);

        hcl += `resource "${type}" "${resourceName}" {\n`;

        // Find edges connected to this node's inputs
        const incomingEdges = edges.filter((edge) => edge.target === node.id);
        const connectedInputs = new Set(incomingEdges.map(edge => edge.targetHandle));

        // Add variables
        Object.entries(variables).forEach(([key, value]) => {
            if (key === '__block_label__') return; // Skip internal block label
            if (connectedInputs.has(key)) return; // Skip if connected, will be handled by edges

            let formattedValue = value;
            if (typeof value === 'string') {
                if (value.trim().startsWith('{') || value.trim().startsWith('[')) {
                    formattedValue = value;
                } else {
                    formattedValue = `"${value}"`;
                }
            }
            hcl += `  ${key} = ${formattedValue}\n`;
        });

        // Add connections (dependencies)
        incomingEdges.forEach((edge) => {
            const sourceNode = nodes.find((n) => n.id === edge.source);
            if (sourceNode) {
                const sourceName = getResourceName(sourceNode);

                if (edge.targetHandle) {
                    hcl += `  ${edge.targetHandle} = ${sourceNode.data.type}.${sourceName}.${edge.sourceHandle || 'id'}\n`;
                }
            }
        });

        hcl += '}\n\n';
    });

    // Generate outputs
    outputs.forEach((node) => {
        hcl += generateOutput(node, edges, nodes) + '\n';
    });

    return hcl;
};
